import { OptionsField, TypeMapJavaScript, TypeMapGolang } from "leon/umbrella/main";
import protobuf from "protobufjs";
import path from "path";
import fs from "fs";

const protoTypeToGo = (field: protobuf.Field): string => {
    const baseType = TypeMapGolang[field.type] || field.type;
    const isOptional = getOptionals(field);

    if (field.repeated) {
        return `[]${baseType}`;
    }

    if (isOptional) {
        return `*${baseType}`;
    }

    return baseType;
}

const protoTypeToTS = (field: protobuf.Field): string => {

    const baseType = TypeMapJavaScript[field.type] || field.type;

    if (field.repeated) {
        return `${baseType}[]`;
    }

    return baseType;
}

const getOptionals = (field: protobuf.Field): boolean => {
    return Boolean(field.toJSON()?.options?.[OptionsField])
}

// Generate TypeScript interfaces
const generateInterfaces = (namespace: protobuf.Namespace): string => {
    let output = "";

    namespace.nestedArray.forEach((nested) => {
        if (nested instanceof protobuf.Service) {
            return;
        }

        if (nested instanceof protobuf.Type) {
            // This is a message
            output += `\ninterface ${nested.name} {\n`;
            // Iterate through all fields
            nested.fieldsArray.forEach((field) => {
                const tsType = protoTypeToTS(field);
                const isOptionalProperty = getOptionals(field)
                const optionalMarker = isOptionalProperty ? "?" : "";

                output += `  ${field.name}${optionalMarker}: ${tsType};\n`;
            });

            output += `}\n`;
        }
    });

    return output;
}

// Convert snake_case to camelCase
const snakeToCamel = (str: string): string => {
    return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
}

// Convert snake_case to PascalCase
const snakeToPascal = (str: string): string => {
    return str.replace(/(^|_)([a-z])/g, (_, __, letter) => letter.toUpperCase());
}

const generateGoStructs = (namespace: protobuf.Namespace): string => {
    let output = "";

    namespace.nestedArray.forEach((nested) => {
        if (nested instanceof protobuf.Service) {
            return;
        }

        if (nested instanceof protobuf.Type) {
            // This is a message
            output += `\ntype ${nested.name} struct {\n`;
            // Iterate through all fields
            nested.fieldsArray.forEach((field) => {
                const goType = protoTypeToGo(field);
                const fieldName = snakeToPascal(field.name);
                const jsonTag = field.name;
                const isOptional = getOptionals(field);
                const omitempty = isOptional ? ",omitempty" : "";

                output += `\t${fieldName} ${goType} \`json:"${jsonTag}${omitempty}"\`\n`;
            });

            output += `}\n`;
        }
    });

    return output;
}


//if the file not exists, create it
// happy first is only replace the content between the divider

export const GenerateFileTypeScript = (pkg: protobuf.Namespace, packageName: string, protoDir: string) => {
    const interfaces = generateInterfaces(pkg);

    const divider = "//" + "=".repeat(50)

    const desc = `// This file was generated by the protobuf compiler. Do not edit.`;

    const fileContent = `${desc}\n${divider}\n${interfaces}\n${divider}`;

    const fileNameTypes = `${packageName}.d.ts`;

    if (!fs.existsSync(path.join(protoDir, fileNameTypes))) {
        fs.writeFileSync(path.join(protoDir, fileNameTypes), fileContent);
    } else {
        const fileContent = fs.readFileSync(path.join(protoDir, fileNameTypes), 'utf8');
        const oldContent = fileContent.split(divider)[1];
        const newContent = fileContent.replace(oldContent, interfaces);
        fs.writeFileSync(path.join(protoDir, fileNameTypes), newContent);
    }
}

export const GenerateFileGolang = (pkg: protobuf.Namespace, packageName: string, protoDir: string) => {
    const structs = generateGoStructs(pkg);

    const divider = "//" + "=".repeat(50)

    const desc = `// This file was generated by the protobuf compiler. Do not edit.`;
    const packageDeclaration = `package ${packageName}`;

    const fileContent = `${desc}\n${divider}\n\n${packageDeclaration}\n${structs}\n${divider}`;

    const fileNameTypes = `${packageName}.go`;

    if (!fs.existsSync(path.join(protoDir, fileNameTypes))) {
        fs.writeFileSync(path.join(protoDir, fileNameTypes), fileContent);
    } else {
        const fileContent = fs.readFileSync(path.join(protoDir, fileNameTypes), 'utf8');
        const oldContent = fileContent.split(divider)[1];
        const newContent = fileContent.replace(oldContent, `\n\n${packageDeclaration}\n${structs}\n`);
        fs.writeFileSync(path.join(protoDir, fileNameTypes), newContent);
    }
}









