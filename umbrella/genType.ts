import { optionsField, typeMap } from "leon/umbrella/main";
import protobuf from "protobufjs";
import path from "path";
import fs from "fs";


// Map protobuf types to TypeScript types
const protoTypeToTS = (field: protobuf.Field, makeOptional: boolean = false): string => {

    const baseType = typeMap[field.type] || field.type;

    if (field.repeated) {
        return `${baseType}[]`;
    }

    return baseType;
}

const getOptionals = (field: protobuf.Field): boolean => {
    return Boolean(field.toJSON()?.options?.[optionsField])
}

// Generate TypeScript interfaces
const generateInterfaces = (namespace: protobuf.Namespace): string => {
    let output = "";

    namespace.nestedArray.forEach((nested) => {
        if (nested instanceof protobuf.Service) {
            return;
        }

        if (nested instanceof protobuf.Type) {
            // This is a message
            output += `\ninterface ${nested.name} {\n`;
            // Iterate through all fields
            nested.fieldsArray.forEach((field) => {
                const tsType = protoTypeToTS(field);
                const isOptionalProperty = getOptionals(field)
                const optionalMarker = isOptionalProperty ? "?" : "";

                output += `  ${field.name}${optionalMarker}: ${tsType};\n`;
            });

            output += `}\n`;
        }
    });

    return output;
}

export const GenerateFile = (pkg: protobuf.Namespace, packageName: string, protoDir: string) => {
    const interfaces = generateInterfaces(pkg);

    const divider = "//" + "=".repeat(50)

    const desc = `// This file was generated by the protobuf compiler. Do not edit.`;

    const fileContent = `${desc}\n${divider}\n${interfaces}\n${divider}`;


    //create a file with the interfaces

    const fileNameTypes = `${packageName}.d.ts`;


    //if the file not exists, create it
    // happy first is only replace the content between the divider
    if (!fs.existsSync(path.join(protoDir, fileNameTypes))) {
        fs.writeFileSync(path.join(protoDir, fileNameTypes), fileContent);
    } else {
        const fileContent = fs.readFileSync(path.join(protoDir, fileNameTypes), 'utf8');
        const oldContent = fileContent.split(divider)[1];
        const newContent = fileContent.replace(oldContent, interfaces);
        fs.writeFileSync(path.join(protoDir, fileNameTypes), newContent);
    }


}








